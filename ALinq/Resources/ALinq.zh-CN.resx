<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UnhandledBindingType" xml:space="preserve">
    <value>未处理的绑定类型: {0}</value>
  </data>
  <data name="CannotAddChangeConflicts" xml:space="preserve">
    <value>无法添加更改冲突。在 SubmitChanges 过程将自动添加这些冲突。</value>
  </data>
  <data name="ColumnMappedMoreThanOnce" xml:space="preserve">
    <value>映射问题: 数据库列“{0}”映射了多次。</value>
  </data>
  <data name="IncludeNotAllowedAfterFreeze" xml:space="preserve">
    <value>在冻结或附加到 DataContext 后，不允许使用 LoadWith。</value>
  </data>
  <data name="OwningTeam" xml:space="preserve">
    <value>ALinq</value>
  </data>
  <data name="CouldNotConvert" xml:space="preserve">
    <value>无法从类型“{0}”转换为类型“{1}”。</value>
  </data>
  <data name="InsertAutoSyncFailure" xml:space="preserve">
    <value>成员 AutoSync 失败。对于要在插入后自动同步的成员，类型必须具有自动生成的标识或在插入后未被数据库修改的键。</value>
  </data>
  <data name="SubqueryNotSupportedOn" xml:space="preserve">
    <value>“{0}”上不支持 Subquery。</value>
  </data>
  <data name="TypeCouldNotBeRemoved" xml:space="preserve">
    <value>无法移除类型“{0}”的实例。此类型不是所映射类型系统的一部分。</value>
  </data>
  <data name="LoadOptionsChangeNotAllowedAfterQuery" xml:space="preserve">
    <value>从查询中返回结果后，将不允许设置加载选项。</value>
  </data>
  <data name="ArgumentTypeHasNoIdentityKey" xml:space="preserve">
    <value>类型“{0}”没有标识键</value>
  </data>
  <data name="EntitySetModifiedDuringEnumeration" xml:space="preserve">
    <value>在枚举期间修改了 EntitySet。</value>
  </data>
  <data name="OriginalEntityIsWrongType" xml:space="preserve">
    <value>原始状态实例的类型不正确。</value>
  </data>
  <data name="CouldNotAttach" xml:space="preserve">
    <value>数据上下文中已存在此项。</value>
  </data>
  <data name="UnrecognizedRefreshObject" xml:space="preserve">
    <value>无法识别指定用于刷新的对象。</value>
  </data>
  <data name="CantAddAlreadyExistingKey" xml:space="preserve">
    <value>不能添加其键已在使用中的实体。</value>
  </data>
  <data name="TypeIsNotEntity" xml:space="preserve">
    <value>类型“{0}”不是实体。</value>
  </data>
  <data name="ExpectedQueryableArgument" xml:space="preserve">
    <value>参数 {0} 不实现 {1}。</value>
  </data>
  <data name="InsertCallbackComment" xml:space="preserve">
    <value>-- 针对插入操作回调到用户代码中。</value>
  </data>
  <data name="OptionsCannotBeModifiedAfterQuery" xml:space="preserve">
    <value>从查询中返回了结果后，将无法修改数据上下文选项。</value>
  </data>
  <data name="RowNotFoundOrChanged" xml:space="preserve">
    <value>找不到行或行已更改。</value>
  </data>
  <data name="SubqueryDoesNotSupportOperator" xml:space="preserve">
    <value>Subquery 中不支持运算符“{0}”。</value>
  </data>
  <data name="CannotPerformCUDOnReadOnlyTable" xml:space="preserve">
    <value>由于“{0}”没有主键，因此无法在其上执行 Create、Update 或 Delete 操作。</value>
  </data>
  <data name="CannotAttachAsModifiedWithoutOriginalState" xml:space="preserve">
    <value>如果实体声明了版本成员或者没有更新检查策略，则只能将它附加为没有原始状态的已修改实体。</value>
  </data>
  <data name="EntitySetDataBindingWithAbstractBaseClass" xml:space="preserve">
    <value>无法将抽象类的实例添加到 EntitySet&lt;{0}&gt;。</value>
  </data>
  <data name="CannotPerformOperationForUntrackedObject" xml:space="preserve">
    <value>不能为实体执行此操作，原因是没有对它进行更改跟踪。</value>
  </data>
  <data name="KeyIsWrongSize" xml:space="preserve">
    <value>键大小不正确。需要为 {0}，实际为 {1}。</value>
  </data>
  <data name="EntityIsTheWrongType" xml:space="preserve">
    <value>实体的类型不正确。</value>
  </data>
  <data name="DatabaseGeneratedAlreadyExistingKey" xml:space="preserve">
    <value>数据库生成了已被使用的键。</value>
  </data>
  <data name="CannotChangeInheritanceType" xml:space="preserve">
    <value>不允许: 如果将继承鉴别器从“{0}”更改为“{1}”，则会将类型从“{2}”更改为“{3}”。</value>
  </data>
  <data name="DataContextCannotBeUsedAfterDispose" xml:space="preserve">
    <value>在 Dispose 后访问的 DataContext。</value>
  </data>
  <data name="InvalidLoadOptionsLoadMemberSpecification" xml:space="preserve">
    <value>指定的表达式必须为 p.A 形式，其中 p 是参数，A 是属性或字段成员。</value>
  </data>
  <data name="EntitySetDataBindingWithNonPublicDefaultConstructor" xml:space="preserve">
    <value>使用 IBindingList 添加新实例时，{0} 必须具有无参数的构造函数。</value>
  </data>
  <data name="ModifyDuringAddOrRemove" xml:space="preserve">
    <value>无法修改 EntitySet。</value>
  </data>
  <data name="SubqueryNotAllowedAfterFreeze" xml:space="preserve">
    <value>在冻结或附加到 DataContext 后，不允许使用 SetSubquery。</value>
  </data>
  <data name="CannotAttachAlreadyExistingEntity" xml:space="preserve">
    <value>无法附加已经存在的实体。</value>
  </data>
  <data name="ObjectTrackingRequired" xml:space="preserve">
    <value>没有为当前数据上下文实例启用对象跟踪。</value>
  </data>
  <data name="InconsistentAssociationAndKeyChange" xml:space="preserve">
    <value>成员“{0}” 已更改为与关联成员“{1}”不一致。</value>
  </data>
  <data name="UnhandledExpressionType" xml:space="preserve">
    <value>未处理的表达式类型: {0}</value>
  </data>
  <data name="TypeIsNotMarkedAsTable" xml:space="preserve">
    <value>类型“{0}”未映射为 Table。</value>
  </data>
  <data name="UnableToDetermineDataContext" xml:space="preserve">
    <value>无法为已编译查询执行确定 DataContext。</value>
  </data>
  <data name="CannotAttachAddNonNewEntities" xml:space="preserve">
    <value>已尝试 Attach 或 Add 实体，该实体不是新实体，可能是从其他 DataContext 中加载来的。不支持这种操作。</value>
  </data>
  <data name="UpdatesFailedMessage" xml:space="preserve">
    <value>{1} 的 {0} 更新失败。</value>
  </data>
  <data name="CannotRemoveChangeConflicts" xml:space="preserve">
    <value>无法删除更改冲突。</value>
  </data>
  <data name="KeyValueIsWrongType" xml:space="preserve">
    <value>键值的类型不正确。需要可从 {0} 中赋值，实际为 {1}。</value>
  </data>
  <data name="DeferredLoadingRequiresObjectTracking" xml:space="preserve">
    <value>延迟加载需要同时启用对象跟踪。</value>
  </data>
  <data name="CannotPerformOperationOutsideSubmitChanges" xml:space="preserve">
    <value>在调用 SubmitChanges 期间，只能在由用户重写的方法内部执行此操作。</value>
  </data>
  <data name="DeleteCallbackComment" xml:space="preserve">
    <value>-- 为删除操作回调到用户代码中。</value>
  </data>
  <data name="CantAddAlreadyExistingItem" xml:space="preserve">
    <value>不能添加已经存在的实体。</value>
  </data>
  <data name="EntitySetAlreadyLoaded" xml:space="preserve">
    <value>EntitySet 已加载，并且无法更改源。</value>
  </data>
  <data name="NonEntityAssociationMapping" xml:space="preserve">
    <value>成员“{0}.{1}”的关联映射无效。“{2}”不是实体。</value>
  </data>
  <data name="DbGeneratedChangeNotAllowed" xml:space="preserve">
    <value>某一“{1}”类型的对象的成员“{0}”的值已更改。
无法更改由数据库计算或生成的成员。</value>
  </data>
  <data name="CycleDetected" xml:space="preserve">
    <value>在更改集中检测到循环。</value>
  </data>
  <data name="CannotRemoveUnattachedEntity" xml:space="preserve">
    <value>无法删除尚未附加的实体。</value>
  </data>
  <data name="IdentityChangeNotAllowed" xml:space="preserve">
    <value>类型为“{1}”的对象的成员“{0}”的值已更改。
无法更改定义对象标识的成员。.
请改为考虑添加具有新标识的新对象，并删除现有的对象。</value>
  </data>
  <data name="ProviderDoesNotImplementRequiredInterface" xml:space="preserve">
    <value>指定的提供程序类型“{0}”不实现“{1}”。</value>
  </data>
  <data name="TypeCouldNotBeTracked" xml:space="preserve">
    <value>无法跟踪类型“{0}”的实例。此类型不是所映射类型系统的一部分。</value>
  </data>
  <data name="IncludeCycleNotAllowed" xml:space="preserve">
    <value>LoadOptions LoadWith 类型图中不允许出现循环。</value>
  </data>
  <data name="ProviderTypeNull" xml:space="preserve">
    <value>应为非 null 提供程序类型。</value>
  </data>
  <data name="ExpectedUpdateDeleteOrChange" xml:space="preserve">
    <value>应为 update、delete 或 change。</value>
  </data>
  <data name="CannotPerformOperationDuringSubmitChanges" xml:space="preserve">
    <value>在调用 SubmitChanges 期间不能执行此操作。</value>
  </data>
  <data name="CouldNotGetTableForSubtype" xml:space="preserve">
    <value>无法为继承子类型“{0}”检索表，请改为尝试 {1} 的表。</value>
  </data>
  <data name="UpdateCallbackComment" xml:space="preserve">
    <value>-- 针对更新操作回调到用户代码中。</value>
  </data>
  <data name="SubqueryMustBeSequence" xml:space="preserve">
    <value>Subquery 必须是序列表达式。</value>
  </data>
  <data name="CouldNotRemoveRelationshipBecauseOneSideCannotBeNull" xml:space="preserve">
    <value>试图删除 {0} 和 {1} 之间的关系。但是，关系的其中一个外键 ({2}) 无法设置为 null。</value>
  </data>
  <data name="SubqueryNotSupportedOnType" xml:space="preserve">
    <value>类型为“{1}”的“{0}”上不支持 Subquery。</value>
  </data>
  <data name="RefreshOfDeletedObject" xml:space="preserve">
    <value>无法刷新指定的对象。对象不再存在于数据库中。</value>
  </data>
  <data name="TypeCouldNotBeAdded" xml:space="preserve">
    <value>无法添加类型“{0}”的实例。此类型不是所映射类型系统的一部分。</value>
  </data>
</root>