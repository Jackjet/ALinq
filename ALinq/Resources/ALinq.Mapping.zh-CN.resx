<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbstractClassAssignInheritanceDiscriminator" xml:space="preserve">
    <value>不应将继承鉴别器键赋给抽象类“{0}”。</value>
  </data>
  <data name="BadFunctionTypeInMethodMapping" xml:space="preserve">
    <value>映射问题: 方法“{0}”的映射中的函数类型不正确。</value>
  </data>
  <data name="BadKeyMember" xml:space="preserve">
    <value>找不到类型“{2}”的键“{1}”的键成员“{0}”。该键可能是错误的，或者“{2}”的字段或属性的名称已发生更改。</value>
  </data>
  <data name="BadStorageProperty" xml:space="preserve">
    <value>存储属性不正确: 成员“{1}.{2}”上的“{0}”。</value>
  </data>
  <data name="CannotGetInheritanceDefaultFromNonInheritanceClass" xml:space="preserve">
    <value>映射问题: 无法从未映射到继承层次结构的类中获取继承默认值。</value>
  </data>
  <data name="CouldNotCreateAccessorToProperty" xml:space="preserve">
    <value>无法创建 {2} 的 PropertyAccessor&lt;{0},{1}&gt;。</value>
  </data>
  <data name="CouldNotFindElementTypeInModel" xml:space="preserve">
    <value>映射问题: 在“{0}”的模型中找不到元素类型。</value>
  </data>
  <data name="CouldNotFindRequiredAttribute" xml:space="preserve">
    <value>映射问题: 找不到必需的属性“{0}”: {1}。</value>
  </data>
  <data name="CouldNotFindRuntimeTypeForMapping" xml:space="preserve">
    <value>映射问题: 找不到类型映射“{0}”的运行库类型。</value>
  </data>
  <data name="CouldNotFindTypeFromMapping" xml:space="preserve">
    <value>映射问题: 在映射中找不到类型“{0}”。</value>
  </data>
  <data name="DatabaseNodeNotFound" xml:space="preserve">
    <value>未找到数据库节点。是否指定了正确的映射命名空间({0})?</value>
  </data>
  <data name="DiscriminatorClrTypeNotSupported" xml:space="preserve">
    <value>鉴别器“{0}.{1}”可能不是“{2}”类型。</value>
  </data>
  <data name="EntityRefAlreadyLoaded" xml:space="preserve">
    <value>EntityRef 已加载，并且无法更改源。</value>
  </data>
  <data name="ExpectedEmptyElement" xml:space="preserve">
    <value>元素“{0}”必须为空，但它包含一个名为“{2}”的 {1} 类型节点。</value>
  </data>
  <data name="IdentityClrTypeNotSupported" xml:space="preserve">
    <value>为标识成员“{0}.{1}”进行的类型映射无效。不支持对标识成员使用类型“{2}”。</value>
  </data>
  <data name="IncorrectAutoSyncSpecification" xml:space="preserve">
    <value>成员“{0}”的 AutoSync 规范不正确</value>
  </data>
  <data name="IncorrectNumberOfParametersMappedForMethod" xml:space="preserve">
    <value>映射问题: 为方法“{0}”映射的参数数量不正确。</value>
  </data>
  <data name="InheritanceCodeMayNotBeNull" xml:space="preserve">
    <value>继承代码值不能为 null。</value>
  </data>
  <data name="InheritanceCodeUsedForMultipleTypes" xml:space="preserve">
    <value>继承代码“{0}”用于多种类型。</value>
  </data>
  <data name="InheritanceHierarchyDoesNotDefineDefault" xml:space="preserve">
    <value>根节点为“{0}”的继承层次结构未定义默认值。</value>
  </data>
  <data name="InheritanceSubTypeIsAlsoRoot" xml:space="preserve">
    <value>继承子类型“{0}”已声明为根类型。</value>
  </data>
  <data name="InheritanceTypeDoesNotDeriveFromRoot" xml:space="preserve">
    <value>继承类型“{0}”未从继承根类型“{1}”派生。</value>
  </data>
  <data name="InheritanceTypeHasMultipleDefaults" xml:space="preserve">
    <value>继承类型“{0}”具有多个默认值。</value>
  </data>
  <data name="InheritanceTypeHasMultipleDiscriminators" xml:space="preserve">
    <value>继承的类型“{0}”不能有多个鉴别器键值。</value>
  </data>
  <data name="InvalidDeleteOnNullSpecification" xml:space="preserve">
    <value>成员“{0}”的 DeleteOnNull 规范无效。对于映射到不可为 null 的外键列的单一实例关联成员，DeleteOnNull 只能为 true。</value>
  </data>
  <data name="InvalidFieldInfo" xml:space="preserve">
    <value>无法从 FieldInfo“{2}”创建 FieldAccessor&lt;{0},{1}&gt;。</value>
  </data>
  <data name="InvalidUseOfGenericMethodAsMappedFunction" xml:space="preserve">
    <value>将泛型方法“{0}”用作映射函数的做法无效。</value>
  </data>
  <data name="LinkAlreadyLoaded" xml:space="preserve">
    <value>链接已加载，并且无法更改源。</value>
  </data>
  <data name="MappedMemberHadNoCorrespondingMemberInType" xml:space="preserve">
    <value>映射中的列或关联“{0}”在类型“{1}”中没有对应的成员。不支持从以上根类型中映射成员。</value>
  </data>
  <data name="MappingForTableUndefined" xml:space="preserve">
    <value>映射问题: 表“{0}”的映射未定义。</value>
  </data>
  <data name="MappingOfInterfacesMemberIsNotSupported" xml:space="preserve">
    <value>不支持接口成员 {0}.{1} 的映射。</value>
  </data>
  <data name="MemberMappedMoreThanOnce" xml:space="preserve">
    <value>成员“{0}”映射了多次。</value>
  </data>
  <data name="MethodCannotBeFound" xml:space="preserve">
    <value>找不到方法“{0}”。</value>
  </data>
  <data name="MismatchedThisKeyOtherKey" xml:space="preserve">
    <value>对于类型“{1}”中的关联属性“{0}”，ThisKey 列的数目与 OtherKey 列的数目不同。</value>
  </data>
  <data name="NoDiscriminatorFound" xml:space="preserve">
    <value>继承类型“{0}”未声明鉴别器列。</value>
  </data>
  <data name="NonInheritanceClassHasDiscriminator" xml:space="preserve">
    <value>继承类型“{0}”具有鉴别器，但不是已映射继承层次结构的一部分。</value>
  </data>
  <data name="NoResultTypesDeclaredForFunction" xml:space="preserve">
    <value>没有为返回 IMultipleResults 的函数“{0}”声明结果类型。</value>
  </data>
  <data name="OwningTeam" xml:space="preserve">
    <value>ALinq</value>
  </data>
  <data name="PrimaryKeyInSubTypeNotSupported" xml:space="preserve">
    <value>子类型“{0}”不能包含主键成员“{1}”。</value>
  </data>
  <data name="ProviderTypeNotFound" xml:space="preserve">
    <value>找不到指定的提供程序类型“{0}”。</value>
  </data>
  <data name="TooManyResultTypesDeclaredForFunction" xml:space="preserve">
    <value>为不返回 IMultipleResults 的函数“{0}”声明了多个结果类型。</value>
  </data>
  <data name="TwoMembersMarkedAsInheritanceDiscriminator" xml:space="preserve">
    <value>成员“{0}”和“{1}”都标记为继承鉴别器。</value>
  </data>
  <data name="TwoMembersMarkedAsPrimaryKeyAndDBGenerated" xml:space="preserve">
    <value>成员“{0}”和“{1}”都标记为 IsPrimaryKey 和 IsDbGenerated。</value>
  </data>
  <data name="TwoMembersMarkedAsRowVersion" xml:space="preserve">
    <value>成员“{0}”和“{1}”都标记为行版本。</value>
  </data>
  <data name="UnableToAssignValueToReadonlyProperty" xml:space="preserve">
    <value>无法将值赋给只读属性“{0}”。</value>
  </data>
  <data name="UnableToResolveRootForType" xml:space="preserve">
    <value>映射问题: 无法为类型“{0}”解析根。</value>
  </data>
  <data name="UnexpectedElement" xml:space="preserve">
    <value>应输入元素“{0}”，但找到“{1}”。</value>
  </data>
  <data name="UnexpectedNull" xml:space="preserve">
    <value>意外的 Null“{0}”。</value>
  </data>
  <data name="UnhandledDeferredStorageType" xml:space="preserve">
    <value>未处理的延迟存储类型: {0}。</value>
  </data>
  <data name="UnmappedClassMember" xml:space="preserve">
    <value>类成员 {0}.{1} 未映射。</value>
  </data>
  <data name="UnrecognizedAttribute" xml:space="preserve">
    <value>映射文件中无法识别的属性“{0}”。</value>
  </data>
  <data name="UnrecognizedElement" xml:space="preserve">
    <value>映射文件中无法识别的元素“{0}”。</value>
  </data>
  <data name="MustBeInterface" xml:space="preserve">
    <value>指定的类型“{0}”必须为接口。</value>
  </data>
  <data name="CannotAccessInterface" xml:space="preserve">
    <value>接口“{0}”不可访问。</value>
  </data>
  <data name="CouldNotFindMappingForDataContextType" xml:space="preserve">
    <value>映射问题: 找不到数据库上下文类型“{0}”的映射。</value>
  </data>
  <data name="DataContextTypeMappedMoreThanOnce" xml:space="preserve">
    <value>数据上下文类型“{0}”映射了多次。</value>
  </data>
</root>